package test;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import sudoku.board.Sudoku;
import sudoku.exceptions.InvalidBoardPositionException;

/**
 * Provides a series of tests that verifies the functionality
 * of the Sudoku1 class.
 *
 * @author Brandon Skar
 * @version 1.0
 */
public class SudokuTest
{
    private Sudoku board;
    //private Sudoku1 board;
    //private Sudoku2 board;
    //private Sudoku3 board;
    //private Sudoku4 board;
    //private Sudoku5 board;
    //private Sudoku6 board;
    //private Sudoku7 board;
    //private Sudoku8 board;
    public static final int BOARD_SIZE = 9;
    public static final int TOTAL_CELLS = BOARD_SIZE * BOARD_SIZE;

    @Before
    public void createBoard()
    {
        board = new Sudoku();
        //board = new Sudoku1();
        //board = new Sudoku2();
        //board = new Sudoku3();
        //board = new Sudoku4();
        //board = new Sudoku5();
        //board = new Sudoku6();
        //board = new Sudoku7();
        //board = new Sudoku8();
    }

    /**
     * Verifies that a new empty board is created
     * when the Sudoku1() constructor is called. The
     * board should be 9x9 and have all empty cells.
     *
     * Hint: you should verify the dimensions of the
     * board and that all elements in the board are 0 (empty).
     */
    @Test
    public void createNewBoardTest()
    {
        int[][] checkBoard = board.getBoard();

        //if there are more than 81 iterations than the test should fail
        int iter = 0;
        for(int i = 0; i < checkBoard.length; i++) {
            for(int j = 0; j < checkBoard[i].length; j++) {
                //increment number of iterations for each cell
                iter++;
            }
        }
        Assert.assertTrue("There were was an incorrect amount of cells on the board." +
                "\nexpected: " + TOTAL_CELLS + "\nactual: " + iter, TOTAL_CELLS == iter);
        //Check to see if every cell is filled with a 0
        for(int i = 0; i < BOARD_SIZE; i++) {
            for(int j = 0; j < BOARD_SIZE; j++) {
                Assert.assertFalse("An empty board must consist of all cells being" +
                        " an integer of 0.\nexpected: 0\nactual: " + checkBoard[i][j], checkBoard[i][j] != 0);
            }
        }
    }

    /**
     * Verifies that invoking the populateBoard()
     * method creates a new board with the expected
     * number of spots revealed.
     *
     * Hint: You don't necessarily need to verify that
     * the revealed spots are invalid, but a good start
     * would be to verify that the given number of spots
     * are actually revealed (i.e. not 0).
     */
    @Test
    public void populateBoardTest()
    {
        int cellFilled = 0;
        int testCells = 40;
        //create a sudoku board with 40 cells filled
        populateBoardTestHelper(testCells, cellFilled);
        //reset board
        cellFilled = 0;
        testCells = -1;

        //create a sudoku board with -1 cells filled, should throw an IllegalArgumentException
        try {
            populateBoardTestHelper(testCells, cellFilled);

            //should not get here
            Assert.fail("Board was created with -1 cells filled, should be in range of 0 to 81");
        } catch(IllegalArgumentException e) {}

        //reset board
        cellFilled = 0;
        testCells = 100;

        //cretae a sudoku board with 100 cells filled, should throw an IllegalArgumentException
        try {
            populateBoardTestHelper(testCells, cellFilled);

            //should not get here
            Assert.fail("Board was created with 100 cells filled, should be in the range of 0 to 81");
        } catch(IllegalArgumentException e) {}

        //reset board
        cellFilled = 0;
        testCells = 0;
        //create a sudoku board with 0 cells filled
        populateBoardTestHelper(testCells, cellFilled);
    }

    private void populateBoardTestHelper(int testCells, int cellFilled)
    {
        board.populateBoard(testCells);
        int[][] checkBoard = board.getBoard();
        for(int i = 0; i < BOARD_SIZE; i++) {
            for(int j = 0; j < BOARD_SIZE; j++) {
                if(checkBoard[i][j] != 0) {
                    cellFilled++;
                }
            }
        }
        //check if cellFilled is equal to testCells
        Assert.assertEquals("The number of cells filled on the board does not match the number" +
                " of cells given.", cellFilled, testCells, 0);

    }

    /**
     * Verifies that the board generated by populateBoard()
     * is actually based on a solution before elements are hidden
     * or revealed.
     *
     * Hint: you can use the spots parameter with a specific
     * value to see if this is the case. The difficulty then
     * is to determine if the values provided are actually
     * a solution. I would strongly suggest that you lean on
     * other methods in the Sudoku1 class to verify this behavior
     */
    @Test
    public void providesActualSolutionTest()
    {
        //check if board is full
        for(int i = 0; i < 1000; i++) {
            board.populateBoard(TOTAL_CELLS);
            if (board.isBoardFull()) {
                //if board is full check if it is solved
                Assert.assertTrue("Board should be full and solved but returning that it is not", board.isSolved());
            }
        }
    }

    /**
     * Verifies that bad inputs to the makeChoice() method
     * throw the appropriate exceptions, according to the
     * Javadoc descriptions.
     *
     * Hint: Make sure to fail the test automatically if
     * the exception is not thrown.
     */
    @Test
    public void makeInvalidChoiceTest()
    {
        board.populateBoard(0);

        //choice 0 should throw an illegal argument exception
        try {
            board.makeChoice(0, 1, 1);

            //shouldnt get here
            Assert.fail("Choice is an invalid test. Should be 1 - 9\nactual: " + 0);
        } catch(IllegalArgumentException e) {}

        //choice 10 should throw an illegal argument exception
        try {
            board.makeChoice(10, 1, 1);

            //shouldnt get here
            Assert.fail("Choice is an invalid test. Should be 1 - 9\nactual: " + 10);
        } catch(IllegalArgumentException e) {}

        //choice -1 should throw an illegal argument exception
        try {
            board.makeChoice(-1, 1, 1);

            //shouldnt get here
            Assert.fail("Choice is an invalid test. Should be 1 - 9\nactual: " + -1);
        } catch(IllegalArgumentException e) {}

        //check to make sure choice is placed in the correct cell
        boolean found = false;
        int[] pos = new int[2];
        board.makeChoice(1, 1, 1);
        int[][] checkBoard = board.getBoard();

        //find where the choice was placed
        for(int i = 0; (i < BOARD_SIZE && !found); i++) {
            for(int j = 0; j < BOARD_SIZE; j++) {
                if(checkBoard[i][j] == 1) {
                    found = true;
                    pos[0] = i;
                    pos[1] = j;
                }
            }
        }
        Assert.assertEquals("Choice was not placed in the correct cell.\nplaced at: [" + pos[0] +
                "," + pos[1] + "]", checkBoard[1][1], 1);
    }

    /**
     * Verifies that a choice can be made on the board with
     * the makeChoice() method. You should be able to call
     * makeChoice() with the same cell and see the value
     * change over time as well.
     *
     * Hint: You can verify the choice by inspecting the
     * board with the getBoard() method.
     */
    @Test
    public void makeValidChoiceTest()
    {
        //check to make sure choice is placed in the correct cell
        board.makeChoice(1, 1, 1);
        int[][] checkBoard = board.getBoard();

        Assert.assertEquals("Choice was not placed in the correct cell.", checkBoard[1][1], 1);

        //check to see that the cell is overridden with the new choice
        board.makeChoice(2, 1, 1);
        checkBoard = board.getBoard();

        Assert.assertEquals("Choice was not placed in the correct cell.", checkBoard[1][1], 2);
    }

    /**
     * Verifies that the int[][] array retrieved by getBoard()
     * is actually a copy of the internal array and not a
     * reference.
     *
     * Hint: You can retrieve the array, make a change, and then
     * retrieve the array again to see if a copy was received or
     * not.
     */
    @Test
    public void boardIsACopyTest()
    {
        int[][] checkBoard = board.getBoard();
        checkBoard[1][1] = 5;
        checkBoard = board.getBoard();
        Assert.assertEquals("The board is a reference, should only be a copy", checkBoard[1][1], 0, 0);
    }

    /**
     * Verifies that a valid row on the board can be identified
     * using the isValidRow() method
     *
     * Hint: Be careful to verify that the method can recognize
     * both valid and invalid rows.
     */
    @Test
    public void validRowTest()
    {
        //test row 9
        try {
            //should throw InvalidBoardPositionException
            board.isRowValid(9);

            //should not get here
            Assert.fail("Added a number to row 9. Rows should be in range of 0. 8");
        } catch(InvalidBoardPositionException e) {}

        //test row -1
        try {
            //should throw InvalidBoardPositionException
            board.isRowValid(-1);

            //should not get here
            Assert.fail("Added a number to row -1. Rows should be in range of 0. 8");
        } catch(InvalidBoardPositionException e) {}
        board.makeChoice(1, 1, 1);
        board.makeChoice(2, 1, 2);

        Assert.assertTrue("Inserting to a row did not work", board.isRowValid(1));
        board.makeChoice(1, 1, 3);

        Assert.assertFalse("Row claims to be valid but it is not, duplicates were not caught", board.isRowValid(1));
    }

    /**
     * Verifies that a valid column on the board can be identified
     * using the isValidColumn() method
     *
     * Hint: Be careful to verify that the method can recognize
     * both valid and invalid columns.
     */
    @Test
    public void validColumnTest()
    {
        //test column 9
        try {
            //should throw InvalidBoardPositionException
            board.isColumnValid(9);

            //should not get here
            Assert.fail("Added a number to column 9. Columns should be in range of 0. 8");
        } catch(InvalidBoardPositionException e) {}

        //test column -1
        try {
            //should throw InvalidBoardPositionException
            board.isColumnValid(-1);

            //should not get here
            Assert.fail("Added a number to column 9. Column should be in range of 0. 8");
        } catch(InvalidBoardPositionException e) {}
        board.makeChoice(1, 1, 1);
        board.makeChoice(2, 2, 1);

        Assert.assertTrue("Inserting to a column did not work", board.isColumnValid(1));
        board.makeChoice(1, 3, 1);

        Assert.assertFalse("Column claims to be valid but it is not. Duplicates were not caught", board.isColumnValid(1));
    }

    /**
     * Verifies that a valid region on the board can be identified
     * using the isValidRegion() method.
     *
     * Hint: Be careful to verify that the method can recognize
     * both valid and invalid regions.
     */
    @Test
    public void validRegionTest()
    {
        //test region 9
        try {
            board.isRegionValid(9);
        } catch(InvalidBoardPositionException e) {}

        //test region -1
        try {
            board.isRegionValid(-1);
        } catch(InvalidBoardPositionException e) {}

        board.makeChoice(1, 0, 0);
        board.makeChoice(2, 1, 1);

        Assert.assertTrue("Column is not valid", board.isRegionValid(0));
        board.makeChoice(1, 2, 2);

        Assert.assertFalse("Column is not valid", board.isRegionValid(0));
    }

    /**
     * Verifies that a full board can be detected by the isBoardFull()
     * method.
     *
     * Hint: Be careful to verify that the method can recognize
     * both a full board and an incomplete board.
     */
    @Test
    public void fullBoardTest()
    {
        //fill one row at a time and test if board is full
        for(int i = 0; i < BOARD_SIZE; i++) {
            board.populateBoard(0);
            for(int j = 0; j < BOARD_SIZE; j++) {
                board.makeChoice(j + 1, j, i);
            }
            Assert.assertFalse("Board claims to be full when it is not", board.isBoardFull());
        }

        //fill one column at a time and test if board is full
        //fill one row at a time and test if board is full
        for(int i = 0; i < BOARD_SIZE; i++) {
            board.populateBoard(0);
            for(int j = 0; j < BOARD_SIZE; j++) {
                board.makeChoice(j + 1, i, j);
            }
            Assert.assertFalse("Board claims to be full when it is not", board.isBoardFull());
        }
    }

    /**
     * Verifies that a solved board can be detected by the isSolved()
     * method.
     *
     * Hint: Be careful to verify that the method can recognize
     * both a solved board and an unsolved board.
     */
    @Test
    public void boardSolvedTest()
    {
        board.populateBoard(0);
        Assert.assertFalse("isSolved is confirming that the board is solved when it is not solved", board.isSolved());
    }
}
